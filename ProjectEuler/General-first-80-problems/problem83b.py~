##############
# Problem 83 #
##############
"""
In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, by only moving to the right and down, is indicated in bold red and is equal to 2427.


Find the minimal path sum, in matrix.txt (right click and "Save Link/Target As..."), a 31K text file containing a 80 by 80 matrix, from the top left to the bottom right by only moving right and down.
"""
# 425185
import time
from stacksnqueues import FILO

def pathSumFourWays():
  """ Question, what is the smallest sum path through
  grid? """
  grid = []
  # populate grid
  with open("p083_matrix.txt", "r") as f:
    for lines in f:
      grid.append(lines.rstrip('\n').split(','))
  f.close()
  # Convert strings to ints
  for row in range(len(grid)):
    for col in range(len(grid[row])):
      grid[row][col] = int(grid[row][col])
  
  routes = pathFinder(grid, len(grid) - 1, len(grid[len(grid) - 1]) - 1)
  lowest = 99999999999999
  # get the lowest sum route
  for n in routes:
    if n < lowest:
      lowest = n
  # return the answer to question
  return(lowest)

 

def pathFinder(grid, endY, endX):
  """ Andy Perrett implementation of well known algorithm
  using my own stack object - recursive backtracker
  """
  count = 2
  smallest = 9999999999999999999
  exhausted = 0
  # Stack to keep track of path 
  stack = FILO()
  # Holds a list of path values
  routes = []
  # Keep track of where we've been and which direction we took
  visited = [[0 for i in range(len(grid))] for j in range(len(grid[0]))]
  Y = 0
  X = 0
  total = 0
  for i in range(10):
    visited[Y][X] |= 0b10000100
    X += 1
    stack.push((Y, X))
    total += grid[Y][X]
    visited[Y][X] |= 0b10000010
    Y += 1
    stack.push((Y, X))
    total += grid[Y][X]
  Y += 1
  
  while 1:
    # start at top left
    stack.push((Y, X))
    # we can stop after 1 minute
    start = time.time()
    # Are we there yet?
    
    print("Starting From:", stack.top())
    while not (stack.top()[1] == endX and stack.top()[0] == endY):#  and (time.time() - start) < 60
      # Check if there is a neighbiour - if not backtrack until we find one
      found = 0
      # Find a neighbour, if not go back and look again
      while found == 0:
        # Get last move
        move = stack.top()
        #print("1:move",move, total)
        #time.sleep(1)
        #print("move = ", move)
        # get lowest valued neighbour
        neighbour = getLowestNeighbour(grid, visited, stack, move[0], move[1])
        # If no neighbour
        if neighbour == (-1, -1) or (total + grid[move[0]][move[1]] > smallest):
          #print("This detection works")
          # this is our exit

          # pop the stack (we don't need the popped value)
          lastMove = stack.pop()
          total -= grid[lastMove[0]][lastMove[1]] 
          if stack.count() == 0:
            print("Exhausted")
            exhausted = 1
            break
          #print("pop",stack)
        # if there is a neighbour continue
        else:
          found = 1
      if exhausted: 
        break
      # We have next move
      move = neighbour 
      #print(move)
      # put the new move onto stack
      stack.push((move[0], move[1]))
      total += grid[move[0]][move[1]]
      if total > smallest:
        print("we break total too high")
        break
      # The previous move is on the stack
      previousMove = stack.getItem(stack.count()-2)
      # Compare previousMove with move to get the
      # direction or multi direction of travel. I store the direction that
      # was taken from this cell. It's needed for drawing the route and for making
      # sure we don't find the same route again.
      if move[0] < previousMove[0]:
        visited[previousMove[0]][previousMove[1]] |= 0b10000001 # north
      if move[0] > previousMove[0]:
        visited[previousMove[0]][previousMove[1]] |= 0b10000010 # south
      if move[1] > previousMove[1]:
        visited[previousMove[0]][previousMove[1]] |= 0b10000100 # east
      if move[1] < previousMove[1]:
        visited[previousMove[0]][previousMove[1]] |= 0b10001000 # west
      # Set current move to visited
      visited[move[0]][move[1]] |= 0b10000000
      
      
      
      
    # Timedout - return the routes we have. If it hasn't answered Euler problem 83
    # We need a different way :)
    if exhausted:
      print("Number of routes", len(routes))
      print("Routes", routes)
      print(move)
      stack.push((0,0))
      #return(routes)
    # sum this route
    if not exhausted:
      if stack.top() == (endY, endX):
        s = 0
        for move in stack:
          s += grid[move[0]][move[1]]
        routes.append(s)
        print("Route sum: ",s, stack.count())
        if s < smallest:
          smallest = s
        print("Smallest:",smallest)
        print("Routes:",len(routes))
        goodRoute = []
        for n in stack:
          goodRoute.append(n)
        goodCount = stack.count()
        goodReduce = 1
      del stack
      stack = FILO(goodRoute)
      # rewind until there is a choice
      for i in range(goodReduce + 1):
        old = stack.pop()
        #print("popping",old)
        visited[old[0]][old[1]] = 0b10000000
      # Does our new start still have neighbours   
      lastMove = stack.top()
      #neighbour = getLowestNeighbour(grid, visited, stack, lastMove[0] , lastMove[1])
      while (-1, -1) == getLowestNeighbour(grid, visited, stack, lastMove[0] , lastMove[1]) and stack.count() > 0:
        # no, go back 1
        lastMove = stack.pop()
        visited[lastMove[0]][lastMove[1]] = 0b10000000      
        goodReduce += 1
        lastMove = stack.top()
    # lets start from here this time
    lastMove = stack.pop()
    total -= grid[lastMove[0]][lastMove[1]]
    Y = lastMove[0]
    X = lastMove[1] 
    print("Start:",Y,X)
    #time.sleep(2)
    total = 0
    for move in stack:
      total =+ grid[move[0]][move[1]]
    if stack.count() < 2:

      return(routes)


  
def getLowestNeighbour(grid, visited, stack, y , x):
  """ Returns lowest 1 of n neighbours """
  # Find a neighbour. It is possible that we visit the same neighbour
  # but we must arrive at it via a different direction, which ensures
  # we take a different route.
  lowest = 999999999999
  neighbour = (-1, -1)
  neighbours = []
  #print(visited[y][x])
  if y > 0 and not visited[y][x] & 0b00000001: # north
    if not (y - 1, x) in stack:
      # store
      neighbours.append((y - 1, x))
      if grid[y - 1][x] < lowest:
        neighbour = (y - 1, x)
        lowest = grid[y - 1][x]
  if x > 0 and not visited[y][x] & 0b00001000: # west
    if not (y, x - 1) in stack:
      # store
      neighbours.append((y, x - 1))
      if grid[y][x - 1] < lowest:
        neighbour = (y, x - 1)
        lowest = grid[y][x - 1]
  if x < len(grid[y]) - 1 and not visited[y][x] & 0b00000100: # east
    if not (y, x + 1) in stack:
      # store
      neighbours.append((y, x + 1))
      if grid[y][x + 1] < lowest:
        neighbour = (y, x + 1)
        lowest = grid[y][x + 1]
  if y < len(grid) - 1 and not visited[y][x] & 0b00000010: # south
    if not (y + 1, x) in stack:
      # store
      neighbours.append((y + 1, x))
      if grid[y + 1][x] < lowest:
        neighbour = (y + 1, x)
        lowest = grid[y + 1][x]
  if neighbour == (-1, -1) and len(neighbours) > 0:
    # perhaps neighbours are equal
    #print("neighbours equal")
    #time.sleep(1)
    #print(neighbours[0])
    return(neighbours[0])
    
  #time.sleep(1)
  #print(y,x , neighbour)
  #if neighbour == (-1, -1):
    #print("no neighbour returning (-1, -1)")
    #time.sleep(1)
  return(neighbour)    
    
 
print("Problem 83")
start = time.time()
print("Path sum four ways: ", pathSumFourWays())
end = time.time()
print("Time taken: " + str(int( ((end - start)*1000)     *100)/100) + " milli seconds")
print()

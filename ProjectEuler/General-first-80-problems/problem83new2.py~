##############
# Problem 83 #
##############

# Standard imports
import math

# Node structure
class ASTARNode():
  localGoal = math.inf
  globalGoal = math.inf
  parent = (-1, -1)
  visited = False
  neighbours = []
  cost = 0

#################################
# Functions specific to problem #
#################################
def heuristic(grid, start, end):
  # Euclidean Distance
  y = abs(end[0] - start[0])
  x = abs(end[1] - start[1])
  return(math.sqrt(y * y + x * x))
def heuristic2(grid, start, end):
  # Euclidean Distance
  cost = 0
  (startY, startX) = start
  (endY, endX) = end
  # Direction of travel
  if (endX - startX) < 0:
    x = -1
  else:
    x = 1
  if (endY - startY) < 0:
    y = -1
  else:
    y = 1
  
  xSum = 0
  while startX != endX:
    xSum += 1
    startX += x
  xSum += 1  

  ySum = 0
  while startY != endY:
    ySum += 1
    startY += y
  ySum += 1
  
  cost = math.sqrt(ySum**2  + xSum**2)
  return(cost)

def getNeighbours(grid, row, col):
  neighbours = []
  if row > 0:
    neighbours.append((row - 1, col)) # up
  if row < len(grid) - 1:
    neighbours.append((row + 1, col)) # down
  if col < len(grid[row]) - 1:
    neighbours.append((row, col + 1)) # right
  if col > 0:
    neighbours.append((row, col - 1)) # left
  return(neighbours)

def foundRoute(grid, start, end):
  pathSum = grid[end[0]][end[1]].cost
  t = []
  (y, x) = end
  while grid[y][x].parent != (-1, -1):
    t.append((y, x))
    (y, x) = grid[y][x].parent
    pathSum += grid[y][x].cost
  t.append(start)
  return(t, pathSum)
 
lowest = math.inf
gridF = []
grid = []
# populate grid with ints from string file
with open("p082_matrix.txt", "r") as f:
  for lines in f:
    gridF.append([int(i) for i in lines.split(',')])
f.close()

# Shortest path cost here is 2297
# (0, 0), (1, 0), (1, 1), (1, 2), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (2, 3), (3, 3), (4, 3), (4, 4)

#gridF = []
#gridF.append([131,673,234,103,18])
#gridF.append([201,96,342,965,150])
#gridF.append([630,803,746,422,111])
#gridF.append([537,699,497,121,956])
#gridF.append([805,732,524,37,331])

routes = []
lowestRoute = math.inf
# Initialise our working grid
grid = [[0 for i in range(len(gridF))] for j in range(len(gridF[0]))]
for row in range(len(gridF)):
  for col in range(len(gridF[0])):
    node = ASTARNode()
    grid[row][col] = node
    grid[row][col].cost = gridF[row][col]

start = (0,0)
end = (len(grid) - 1 , len(grid[0]) - 1)
# Start point
(y, x) = start
# Set starting localGoal and set to zero
grid[y][x].localGoal = 0
nodes = []
nodes.append(start)
while True:
  # Loop thru neighbours
  for neighbour in getNeighbours(grid, y, x): 
    # Test each neighbour
    (Y, X) = neighbour
    localCost = grid[y][x].localGoal + grid[Y][X].cost
    # Update if lower cost
    if localCost < grid[Y][X].localGoal:
      grid[Y][X].localGoal = localCost
      grid[Y][X].parent = (y, x)
      # Calculate heuristic 
      grid[Y][X].globalGoal = heuristic(grid, (Y, X), end) + localCost
    if not grid[neighbour[0]][neighbour[1]].visited:   
      nodes.append(neighbour)
  grid[y][x].visited = True
  # Priority Queue
  nodes.sort(key=lambda c: grid[c[0]][c[1]].globalGoal)
  # Clean the queue
  found = False
  while not found and len(nodes) != 0:
    node = nodes[0]
    if grid[node[0]][node[1]].visited == False:
      found = True
    else:
      nodes.remove(nodes[0])
  if len(nodes) == 0:
    # Found shortest
    break
  (y, x) = nodes[0]
# Track back path to find route and cost
t, pathSum = foundRoute(grid, start, end)
# Do we have a lower cost route? 
if pathSum < lowestRoute:
  lowestRoute = pathSum
  routes = t
  print("PathSUM",pathSum,)
  print(list(reversed(routes)))


 
